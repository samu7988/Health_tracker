/**
 * @file adc.c
 * @brief This file is to be used for the setting the ADC of the microcontroller.
 * @author Sayali mule
 * @date November 12, 2021
 * @Reference/Credits:
 *
 *
 */

//***********************************************************************************
// Include files
//***********************************************************************************

#include "adc.h"
//***********************************************************************************
// Macros
//***********************************************************************************
#define adcFreq   16000000
#define NUM_INPUTS (2)
#define MAX_VOLTAGE_L 2640
#define MAX_VOLTAGE_R 2640
#define MIN_VOLTAGE_L 2120
#define MIN_VOLTAGE_R 1785
//***********************************************************************************
// Global variables
//***********************************************************************************

volatile uint32_t sample;
volatile uint32_t millivolts;
extern uint32_t inputs[NUM_INPUTS];

//***********************************************************************************
// Function implementation
//***********************************************************************************
/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
  @brief: Initialise ADC peripheral

 Set the Reference voltage, Acquisition time, ADC channel input selection and enabling the ADC interrupt

 @param:None
 @param:None
PF7 adcPosSelAPORT2XCH23, PD13 APORT4XCH5
 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void ADC_init(){

    // Declare init structs
    ADC_Init_TypeDef init =
        {                                                                        \
        adcOvsRateSel2,              /* 2x oversampling (if enabled). */       \
        adcWarmupNormal,             /* ADC shutdown after each conversion. */ \
        _ADC_CTRL_TIMEBASE_DEFAULT,  /* Use hardware default value. */         \
        _ADC_CTRL_PRESC_DEFAULT,     /* Use hardware default value. */         \
        false,                       /* Do not use tailgate. */                \
        adcEm2Disabled               /* ADC disabled in EM2. */                \
      };
    ADC_InitScan_TypeDef initScan =
    {                                                                                   \
      adcPRSSELCh0,            /* PRS ch0 (if enabled). */                              \
      adcAcqTime1,             /* 1 ADC_CLK cycle acquisition time. */                  \
      adcRef1V25,              /* 1.25 V internal reference. */                         \
      adcRes12Bit,             /* 12 bit resolution. */                                 \
      {                                                                                 \
        /* Initialization should match values set by @ref ADC_ScanInputClear(). */      \
        ADC_SCANINPUTSEL_NONE, /* Default ADC inputs. */                                \
        0,                     /* Default input mask (all off). */                      \
        _ADC_SCANNEGSEL_RESETVALUE,/* Default negative select for positive terminal. */ \
      },                                                                                \
      false,                   /* Single-ended input. */                                \
      false,                   /* PRS disabled. */                                      \
      false,                   /* Right adjust. */                                      \
      false,                   /* Deactivate conversion after one scan sequence. */     \
      false,                   /* No EM2 DMA wakeup from scan FIFO DVL. */              \
      false                    /* Discard new data on full FIFO. */                     \
    }

    // Modify init structs
    init.prescale   = ADC_PrescaleCalc(adcFreq, 0);

    initScan.diff       = 0;            // single ended
    initScan.reference  = adcRef2V5;    // internal 2.5V reference
    initScan.resolution = adcRes12Bit;  // 12-bit resolution
    initScan.acqTime    = adcAcqTime4;  // set acquisition time to meet minimum requirement
    initScan.fifoOverwrite = true;      // FIFO overflow overwrites old data

    // Select ADC input.
    // Add VDD to scan for demonstration purposes
    ADC_ScanSingleEndedInputAdd(&initScan, adcScanInputGroup0, adcPosSelAPORT2XCH23); //PF7
    ADC_ScanSingleEndedInputAdd(&initScan, adcScanInputGroup1, adcPosSelAPORT4XCH5); //PD13

    // Set scan data valid level (DVL) to 2. This will cause the scan IRQ to set when DVL +1 input channels have been converted and result is stored in FIFO
    ADC0->SCANCTRLX |= (NUM_INPUTS - 1) << _ADC_SCANCTRLX_DVL_SHIFT;

    // Clear ADC Scan fifo
    ADC0->SCANFIFOCLEAR = ADC_SCANFIFOCLEAR_SCANFIFOCLEAR;

    // Initialize ADC and Scan
    ADC_Init(ADC0, &init);
    ADC_InitScan(ADC0, &initScan);

    // Enable Scan interrupts
    ADC_IntEnable(ADC0, ADC_IEN_SCAN);

    // Enable ADC interrupts
    NVIC_ClearPendingIRQ(ADC0_IRQn);
    NVIC_EnableIRQ(ADC0_IRQn);
}
/*------------------------------------------------------------------------------------------------------------------------------------*/
/*
  @brief:ADC interrupt handler

 Perform the required function when ADC conversion gets completed

 @param:None
 @param:None

 @return: None
 */
/*-----------------------------------------------------------------------------------------------------------------------------*/
void ADC0_IRQHandler(void)
{
//  ADC_IntClear(ADC0,0xFFFFFFFF);
  //  gecko_external_signal(0);

 /* // Get ADC result
  sample = ADC_DataSingleGet(ADC0);

  // Calculate input voltage in mV
  millivolts = (sample * 3300) / 4096;

  // Start next ADC conversion
  ADC_Start(ADC0, adcStartSingle);*/

    uint32_t data_byte, i, id;

    // Get ADC results
    for(i = 0; i < NUM_INPUTS; i++)
    {
      // Read data from ADC
     data_byte = ADC_DataIdScanGet(ADC0, &id);

      // Convert data to mV and store into array
      inputs[i] = data_byte;
      if(inputs[i] >=MIN_VOLTAGE_L && inputs[i]<=MAX_VOLTAGE_L && i==0){
      inputs[i] = (inputs[i]-MIN_VOLTAGE_L)*255/(MAX_VOLTAGE_L-MIN_VOLTAGE_L);
    }
    else if(inputs[i] <MIN_VOLTAGE_L && i==0){
      inputs[i] =0;
    //inputs[i] = data * 2500 / 4096;
    }
    else if(inputs[i]>MAX_VOLTAGE_L && i==0){
      inputs[i] = 255;
    }

      if(inputs[i] >=MIN_VOLTAGE_R && inputs[i]<=MAX_VOLTAGE_R && i==1){
      inputs[i] = (inputs[i]-MIN_VOLTAGE_R)*255/(MAX_VOLTAGE_R-MIN_VOLTAGE_R);
    }
    else if(inputs[i] <MIN_VOLTAGE_R && i==1){
      inputs[i] =0;
    //inputs[i] = data * 2500 / 4096;
    }
    else if(inputs[i]>MAX_VOLTAGE_R && i==1){
      inputs[i] = 255;
    }
      //inputs[i] = data * 2500 / 4096;
    }
    // Start next ADC conversion
}
